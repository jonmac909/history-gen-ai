/**
 * Invidious API Client
 * Free YouTube frontend API - no rate limits, no API key required
 *
 * Uses public Invidious instances for channel/video data
 */

// Public Invidious instances (fallback order)
const INVIDIOUS_INSTANCES = [
  'https://vid.puffyan.us',
  'https://invidious.nerdvpn.de',
  'https://inv.nadeko.net',
  'https://invidious.privacyredirect.com',
];

let currentInstanceIndex = 0;

function getBaseUrl(): string {
  return INVIDIOUS_INSTANCES[currentInstanceIndex];
}

function rotateInstance(): void {
  currentInstanceIndex = (currentInstanceIndex + 1) % INVIDIOUS_INSTANCES.length;
  console.log(`[invidious] Rotating to instance: ${getBaseUrl()}`);
}

// Types
export interface InvidiousChannel {
  authorId: string;
  author: string;
  authorUrl: string;
  authorThumbnails: { url: string; width: number; height: number }[];
  subCount: number;
  totalViews: number;
  joined: number;
  autoGenerated: boolean;
  isFamilyFriendly: boolean;
  description: string;
  descriptionHtml: string;
  allowedRegions: string[];
  latestVideos: InvidiousVideo[];
}

export interface InvidiousVideo {
  videoId: string;
  title: string;
  videoThumbnails: { url: string; width: number; height: number; quality: string }[];
  lengthSeconds: number;
  viewCount: number;
  author: string;
  authorId: string;
  authorUrl: string;
  published: number; // Unix timestamp
  publishedText: string;
  description: string;
  descriptionHtml: string;
  liveNow: boolean;
  premium: boolean;
  isUpcoming: boolean;
  likeCount?: number;
}

export interface InvidiousSearchResult {
  type: 'video' | 'channel' | 'playlist';
  videoId?: string;
  authorId?: string;
  author: string;
  title?: string;
  subCount?: number;
  videoCount?: number;
  description?: string;
  authorThumbnails?: { url: string; width: number; height: number }[];
}

// Fetch with timeout and retry
async function fetchWithRetry(url: string, maxRetries = 3): Promise<Response> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const instanceUrl = `${getBaseUrl()}${url}`;
    console.log(`[invidious] Fetching: ${instanceUrl} (attempt ${attempt + 1})`);

    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 15000); // 15s timeout

      const response = await fetch(instanceUrl, {
        signal: controller.signal,
        headers: {
          'Accept': 'application/json',
        },
      });

      clearTimeout(timeout);

      if (response.ok) {
        return response;
      }

      // If 5xx error, try next instance
      if (response.status >= 500) {
        console.log(`[invidious] Instance returned ${response.status}, rotating...`);
        rotateInstance();
        continue;
      }

      // 4xx errors are client errors, don't retry
      throw new Error(`Invidious API error: ${response.status} ${response.statusText}`);

    } catch (error: any) {
      lastError = error;

      if (error.name === 'AbortError') {
        console.log(`[invidious] Request timeout, rotating instance...`);
        rotateInstance();
        continue;
      }

      // Network error, try next instance
      console.log(`[invidious] Network error: ${error.message}, rotating...`);
      rotateInstance();
    }
  }

  throw lastError || new Error('All Invidious instances failed');
}

/**
 * Resolve a YouTube handle (@handle) or URL to a channel ID
 */
export async function resolveChannelId(input: string): Promise<string> {
  // Already a channel ID (starts with UC and is 24 chars)
  if (input.startsWith('UC') && input.length >= 24) {
    return input.substring(0, 24);
  }

  // Extract from URL patterns
  const channelIdMatch = input.match(/\/channel\/(UC[\w-]{22})/);
  if (channelIdMatch) {
    return channelIdMatch[1];
  }

  // Handle @handle format
  let handle = input;
  if (input.includes('youtube.com/@')) {
    handle = '@' + input.split('youtube.com/@')[1].split('/')[0].split('?')[0];
  } else if (input.includes('youtube.com/')) {
    // Could be /c/channelname or /user/username
    const pathMatch = input.match(/youtube\.com\/(?:c|user)\/([^\/\?]+)/);
    if (pathMatch) {
      handle = pathMatch[1];
    }
  }

  // Clean the handle
  handle = handle.replace(/^@/, '');

  // Search for channel by name
  const response = await fetchWithRetry(`/api/v1/search?q=${encodeURIComponent(handle)}&type=channel`);
  const results = await response.json() as InvidiousSearchResult[];

  const channelResult = results.find(r => r.type === 'channel');
  if (!channelResult || !channelResult.authorId) {
    throw new Error(`Channel not found: ${input}`);
  }

  return channelResult.authorId;
}

/**
 * Get channel info and stats
 */
export async function getChannel(channelId: string): Promise<InvidiousChannel> {
  const response = await fetchWithRetry(`/api/v1/channels/${channelId}`);
  return await response.json() as InvidiousChannel;
}

/**
 * Get channel videos with pagination
 */
export async function getChannelVideos(
  channelId: string,
  options: {
    maxResults?: number;
    sortBy?: 'newest' | 'oldest' | 'popular';
  } = {}
): Promise<InvidiousVideo[]> {
  const { maxResults = 50, sortBy = 'newest' } = options;

  const videos: InvidiousVideo[] = [];
  let page = 1;
  const perPage = 30; // Invidious default

  while (videos.length < maxResults) {
    const response = await fetchWithRetry(
      `/api/v1/channels/${channelId}/videos?page=${page}&sort_by=${sortBy}`
    );
    const pageVideos = await response.json() as InvidiousVideo[];

    if (pageVideos.length === 0) break;

    videos.push(...pageVideos);
    page++;

    // Safety limit
    if (page > 10) break;
  }

  return videos.slice(0, maxResults);
}

/**
 * Get video details (for like counts, etc.)
 */
export async function getVideo(videoId: string): Promise<InvidiousVideo> {
  const response = await fetchWithRetry(`/api/v1/videos/${videoId}`);
  return await response.json() as InvidiousVideo;
}

/**
 * Search for channels by topic
 */
export async function searchChannels(
  query: string,
  maxResults = 20
): Promise<InvidiousSearchResult[]> {
  const response = await fetchWithRetry(
    `/api/v1/search?q=${encodeURIComponent(query)}&type=channel`
  );
  const results = await response.json() as InvidiousSearchResult[];

  return results
    .filter(r => r.type === 'channel')
    .slice(0, maxResults);
}
