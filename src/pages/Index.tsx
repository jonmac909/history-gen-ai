import { useState, useRef, useEffect } from "react";
import { Youtube, FileText, Sparkles, Scroll, Mic, Image, RotateCcw, TrendingUp, Zap } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Slider } from "@/components/ui/slider";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { toast } from "@/hooks/use-toast";
import { SettingsPopover, type GenerationSettings } from "@/components/SettingsPopover";
import { ProcessingModal, type GenerationStep } from "@/components/ProcessingModal";
import { ConfigModal, type ScriptTemplate, type ImageTemplate, type CartesiaVoice } from "@/components/ConfigModal";
import { ProjectResults, type GeneratedAsset } from "@/components/ProjectResults";
import { ScriptReviewModal } from "@/components/ScriptReviewModal";
import { AudioPreviewModal } from "@/components/AudioPreviewModal";
import { AudioSegmentsPreviewModal } from "@/components/AudioSegmentsPreviewModal";
import { ImagesPreviewModal } from "@/components/ImagesPreviewModal";
import { ImagePromptsPreviewModal } from "@/components/ImagePromptsPreviewModal";
import { CaptionsPreviewModal } from "@/components/CaptionsPreviewModal";
import { ThumbnailGeneratorModal } from "@/components/ThumbnailGeneratorModal";
import { VideoRenderModal } from "@/components/VideoRenderModal";
import { VisualEffectsModal } from "@/components/VisualEffectsModal";
import { YouTubeUploadModal } from "@/components/YouTubeUploadModal";
import {
  getYouTubeTranscript,
  rewriteScriptStreaming,
  generateAudioStreaming,
  regenerateAudioSegment,
  recombineAudioSegments,
  generateCaptions,
  generateImagesStreaming,
  generateImagePrompts,
  saveScriptToStorage,
  type ImagePromptWithTiming,
  type AudioSegment,
} from "@/lib/api";
import { defaultTemplates, defaultImageTemplates } from "@/data/defaultTemplates";
import { supabase } from "@/integrations/supabase/client";
import {
  upsertProject,
  getMostRecentInProgress,
  completeProject,
  archiveProject,
  migrateFromLocalStorage,
  getStepLabel,
  createProjectVersion,
  duplicateProject,
  type Project,
} from "@/lib/projectStore";
import { ProjectsDrawer } from "@/components/ProjectsDrawer";
import { OutlierFinderView } from "@/components/OutlierFinderView";
import { FavoritesView } from "@/components/FavoritesView";

type InputMode = "url" | "title";
type ViewState = "create" | "outlier-finder" | "favorites" | "processing" | "review-script" | "review-audio" | "review-captions" | "review-prompts" | "review-images" | "review-render" | "review-effects" | "review-thumbnails" | "review-youtube" | "results";
type EntryMode = "script" | "captions" | "images";

const LAST_SETTINGS_KEY = "historygenai-last-settings";
const CUSTOM_IMAGE_TEMPLATES_KEY = "historygenai-custom-image-templates";

// Default settings (used when no saved settings exist)
const DEFAULT_SETTINGS: GenerationSettings = {
  projectTitle: "",
  fullAutomation: false,
  scriptTemplate: "template-a",
  imageTemplate: "image-a",
  aiModel: "claude-sonnet-4-5",
  voiceSampleUrl: "https://historygenai.netlify.app/voices/clone_voice.wav",
  speed: 1,
  imageCount: 10,
  wordCount: 1000,
  quality: "basic",
  ttsEmotionMarker: "(sincere) (soft tone)",
  ttsTemperature: 0.9,
  ttsTopP: 0.85,
  ttsRepetitionPenalty: 1.1,
};

// Load last used settings from localStorage
function loadLastSettings(): GenerationSettings {
  try {
    const saved = localStorage.getItem(LAST_SETTINGS_KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      // Merge with defaults to ensure all fields exist
      return {
        ...DEFAULT_SETTINGS,
        ...parsed,
        // Always reset project title for new projects
        projectTitle: "",
        // CRITICAL: fullAutomation must ALWAYS start as false
        // User must explicitly click "Full Auto Generate" each time
        fullAutomation: false,
      };
    }
  } catch (e) {
    console.error("[Index] Failed to load last settings:", e);
  }
  return { ...DEFAULT_SETTINGS };
}

// Save settings to localStorage (called when settings change)
function saveLastSettings(settings: GenerationSettings): void {
  try {
    // Don't save project-specific or session-specific fields
    // fullAutomation should NEVER persist - it must be explicitly chosen each time
    const { projectTitle, customScript, fullAutomation, ...persistableSettings } = settings;
    localStorage.setItem(LAST_SETTINGS_KEY, JSON.stringify(persistableSettings));
  } catch (e) {
    console.error("[Index] Failed to save settings:", e);
  }
}

// Load custom image template overrides from localStorage
function loadCustomImageTemplates(): Record<string, { template: string; name?: string }> {
  try {
    const saved = localStorage.getItem(CUSTOM_IMAGE_TEMPLATES_KEY);
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error("[Index] Failed to load custom image templates:", e);
  }
  return {};
}

// Save custom image template overrides to localStorage
function saveCustomImageTemplates(templates: ImageTemplate[]): void {
  try {
    // Only save templates that differ from defaults
    const customOverrides: Record<string, { template: string; name?: string }> = {};
    for (const template of templates) {
      const defaultTemplate = defaultImageTemplates.find(d => d.id === template.id);
      // Save if template content differs from default, or if it's a new custom template
      if (!defaultTemplate || template.template !== defaultTemplate.template || template.name !== defaultTemplate.name) {
        customOverrides[template.id] = { template: template.template, name: template.name };
      }
    }
    localStorage.setItem(CUSTOM_IMAGE_TEMPLATES_KEY, JSON.stringify(customOverrides));
  } catch (e) {
    console.error("[Index] Failed to save custom image templates:", e);
  }
}

// Merge default templates with custom overrides
function getImageTemplatesWithCustomOverrides(): ImageTemplate[] {
  const customOverrides = loadCustomImageTemplates();
  return defaultImageTemplates.map(template => {
    const override = customOverrides[template.id];
    if (override) {
      return {
        ...template,
        template: override.template,
        name: override.name || template.name,
      };
    }
    return template;
  });
}

const Index = () => {
  const [inputMode, setInputMode] = useState<InputMode>("url");
  const [inputValue, setInputValue] = useState("");
  const [viewState, setViewState] = useState<ViewState>("create");
  // Load settings from localStorage (persists across sessions)
  const [settings, setSettings] = useState<GenerationSettings>(loadLastSettings);
  const [processingSteps, setProcessingSteps] = useState<GenerationStep[]>([]);
  const [scriptTemplates, setScriptTemplates] = useState<ScriptTemplate[]>(defaultTemplates);
  const [imageTemplates, setImageTemplates] = useState<ImageTemplate[]>(getImageTemplatesWithCustomOverrides);
  const [cartesiaVoices, setCartesiaVoices] = useState<CartesiaVoice[]>([]);

  // Get the selected image template content for image generation
  const getSelectedImageStyle = () => {
    const selected = imageTemplates.find(t => t.id === settings.imageTemplate);
    return selected?.template || imageTemplates[0]?.template || "";
  };
  const [sourceUrl, setSourceUrl] = useState("");
  const [generatedAssets, setGeneratedAssets] = useState<GeneratedAsset[]>([]);
  const [audioUrl, setAudioUrl] = useState<string | undefined>();
  const [srtContent, setSrtContent] = useState<string | undefined>();
  
  // Step-by-step state
  const [pendingScript, setPendingScript] = useState("");
  const [confirmedScript, setConfirmedScript] = useState("");
  const [projectId, setProjectId] = useState("");
  const [videoTitle, setVideoTitle] = useState("History Documentary");
  const [pendingAudioUrl, setPendingAudioUrl] = useState("");
  const [pendingAudioDuration, setPendingAudioDuration] = useState<number>(0);
  const [pendingAudioSize, setPendingAudioSize] = useState<number>(0);
  // New: Audio segments state
  const [pendingAudioSegments, setPendingAudioSegments] = useState<AudioSegment[]>([]);
  const [regeneratingSegmentIndex, setRegeneratingSegmentIndex] = useState<number | null>(null);
  const [segmentsNeedRecombine, setSegmentsNeedRecombine] = useState(false);
  const [isRecombining, setIsRecombining] = useState(false);
  const [pendingSrtContent, setPendingSrtContent] = useState("");
  const [pendingSrtUrl, setPendingSrtUrl] = useState("");
  const [pendingImages, setPendingImages] = useState<string[]>([]);
  const [generatedThumbnails, setGeneratedThumbnails] = useState<string[]>([]);
  const [selectedThumbnailIndex, setSelectedThumbnailIndex] = useState<number | undefined>();
  const [favoriteThumbnails, setFavoriteThumbnails] = useState<string[]>(() => {
    try {
      const saved = localStorage.getItem('historygenai-favorite-thumbnails');
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  });
  const [renderedVideoUrl, setRenderedVideoUrl] = useState<string | undefined>();
  const [videoUrl, setVideoUrl] = useState<string | undefined>();
  const [videoUrlCaptioned, setVideoUrlCaptioned] = useState<string | undefined>();
  const [embersVideoUrl, setEmbersVideoUrl] = useState<string | undefined>();
  const [smokeEmbersVideoUrl, setSmokeEmbersVideoUrl] = useState<string | undefined>();
  const [imagePrompts, setImagePrompts] = useState<ImagePromptWithTiming[]>([]);
  const [regeneratingImageIndex, setRegeneratingImageIndex] = useState<number | undefined>();
  const [regeneratingImageIndices, setRegeneratingImageIndices] = useState<Set<number>>(new Set());
  const [entryMode, setEntryMode] = useState<EntryMode>("script");
  const [uploadedAudioFile, setUploadedAudioFile] = useState<File | null>(null);
  const [uploadedScript, setUploadedScript] = useState("");
  const [uploadedCaptions, setUploadedCaptions] = useState("");
  const audioFileInputRef = useRef<HTMLInputElement>(null);
  const audioFileInputImagesRef = useRef<HTMLInputElement>(null);
  const scriptFileInputRef = useRef<HTMLInputElement>(null);
  const captionsFileInputRef = useRef<HTMLInputElement>(null);
  const [uploadedAudioFileForImages, setUploadedAudioFileForImages] = useState<File | null>(null);
  const [savedProject, setSavedProject] = useState<Project | null>(null);
  const [captionsProjectTitle, setCaptionsProjectTitle] = useState("");
  const [imagesProjectTitle, setImagesProjectTitle] = useState("");
  const [customStylePrompt, setCustomStylePrompt] = useState("");
  // Pipeline approval tracking
  type PipelineStep = 'script' | 'audio' | 'captions' | 'prompts' | 'images' | 'thumbnails' | 'render' | 'youtube';
  const [approvedSteps, setApprovedSteps] = useState<PipelineStep[]>([]);
  // YouTube metadata state
  const [youtubeTitle, setYoutubeTitle] = useState("");
  const [youtubeDescription, setYoutubeDescription] = useState("");
  const [youtubeTags, setYoutubeTags] = useState("");
  const [youtubeCategoryId, setYoutubeCategoryId] = useState("27"); // Default: Education
  const [youtubePlaylistId, setYoutubePlaylistId] = useState<string | null>(null);

  // Project tags state
  const [projectTags, setProjectTags] = useState<string[]>([]);

  // Migrate localStorage to Supabase on first load
  useEffect(() => {
    migrateFromLocalStorage();
  }, []);


  // Persist settings to localStorage whenever they change
  useEffect(() => {
    saveLastSettings(settings);
  }, [settings]);

  // Check for in-progress project on load and when returning to create view
  useEffect(() => {
    if (viewState === "create") {
      console.log("[Index] Checking for in-progress project...");
      getMostRecentInProgress().then((inProgress) => {
        console.log("[Index] In-progress project found:", !!inProgress, inProgress?.id);
        if (inProgress) {
          setSavedProject(inProgress);
        } else {
          setSavedProject(null);
        }
      });
    }
  }, [viewState]);

  // Full Automation: Auto-confirm script when ready
  useEffect(() => {
    if (settings.fullAutomation && viewState === "review-script" && pendingScript) {
      console.log("[Full Automation] Auto-confirming script...");
      const timer = setTimeout(() => {
        handleScriptConfirm(pendingScript);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [settings.fullAutomation, viewState, pendingScript]);

  // Full Automation: Auto-confirm audio when ready
  useEffect(() => {
    if (settings.fullAutomation && viewState === "review-audio" && pendingAudioUrl) {
      console.log("[Full Automation] Auto-confirming audio...");
      const timer = setTimeout(() => {
        handleAudioConfirm();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [settings.fullAutomation, viewState, pendingAudioUrl]);

  // Full Automation: Auto-confirm captions when ready
  useEffect(() => {
    if (settings.fullAutomation && viewState === "review-captions" && pendingSrtContent) {
      console.log("[Full Automation] Auto-confirming captions...");
      const timer = setTimeout(() => {
        handleCaptionsConfirm(pendingSrtContent);
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [settings.fullAutomation, viewState, pendingSrtContent]);

  // Full Automation: Auto-confirm prompts when ready
  useEffect(() => {
    if (settings.fullAutomation && viewState === "review-prompts" && imagePrompts.length > 0) {
      console.log("[Full Automation] Auto-confirming image prompts...");
      const timer = setTimeout(() => {
        handlePromptsConfirm(imagePrompts, getSelectedImageStyle());
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [settings.fullAutomation, viewState, imagePrompts]);

  // Full Automation: Auto-confirm images when ready
  useEffect(() => {
    if (settings.fullAutomation && viewState === "review-images" && pendingImages.length > 0) {
      console.log("[Full Automation] Auto-confirming images...");
      const timer = setTimeout(() => {
        handleImagesConfirm();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [settings.fullAutomation, viewState, pendingImages]);

  // Auto-save helper - uses unified project store (upsert by id)
  // Fire-and-forget async to avoid blocking UI
  const autoSave = (step: Project["currentStep"], overrides?: Partial<Project>) => {
    const finalId = overrides?.id || projectId;
    const finalVideoTitle = overrides?.videoTitle || videoTitle;
    console.log(`[autoSave] Saving project id=${finalId}, title=${finalVideoTitle}, step=${step}`);

    upsertProject({
      id: finalId,
      sourceUrl: overrides?.sourceUrl || sourceUrl,
      videoTitle: finalVideoTitle,
      settings: overrides?.settings || settings,
      status: 'in_progress',
      currentStep: step,
      script: overrides?.script || confirmedScript || pendingScript,
      audioUrl: overrides?.audioUrl || pendingAudioUrl,
      audioDuration: overrides?.audioDuration || pendingAudioDuration,
      audioSegments: overrides?.audioSegments || pendingAudioSegments,
      srtContent: overrides?.srtContent || pendingSrtContent,
      srtUrl: overrides?.srtUrl || pendingSrtUrl,
      imagePrompts: overrides?.imagePrompts || imagePrompts,
      imageUrls: overrides?.imageUrls || pendingImages,
      videoUrl: overrides?.videoUrl || videoUrl,
      videoUrlCaptioned: overrides?.videoUrlCaptioned || videoUrlCaptioned,
      embersVideoUrl: overrides?.embersVideoUrl || embersVideoUrl,
      smokeEmbersVideoUrl: overrides?.smokeEmbersVideoUrl || smokeEmbersVideoUrl,
      thumbnails: overrides?.thumbnails || generatedThumbnails,
      selectedThumbnailIndex: overrides?.selectedThumbnailIndex ?? selectedThumbnailIndex,
      youtubeTitle: overrides?.youtubeTitle || youtubeTitle || undefined,
      youtubeDescription: overrides?.youtubeDescription || youtubeDescription || undefined,
      youtubeTags: overrides?.youtubeTags || youtubeTags || undefined,
      youtubeCategoryId: overrides?.youtubeCategoryId || youtubeCategoryId || undefined,
      youtubePlaylistId: overrides?.youtubePlaylistId !== undefined ? overrides.youtubePlaylistId : youtubePlaylistId,
      tags: overrides?.tags || projectTags || undefined,
    }).catch(err => console.error('[autoSave] Failed to save project:', err));
  };

  // Resume saved project
  const handleResumeProject = () => {
    if (!savedProject) return;

    // CRITICAL: Disable fullAutomation when manually resuming a project
    // User is reviewing/editing, not running full automation
    setSettings(prev => ({ ...prev, fullAutomation: false }));

    // Restore state from saved project (but keep current settings so user can change them)
    setProjectId(savedProject.id);
    setSourceUrl(savedProject.sourceUrl);
    setVideoTitle(savedProject.videoTitle);
    // Don't restore settings - use current settings so user can adjust image count, etc.

    if (savedProject.script) {
      setPendingScript(savedProject.script);
      setConfirmedScript(savedProject.script);
    }
    if (savedProject.audioUrl) setPendingAudioUrl(savedProject.audioUrl);
    if (savedProject.audioDuration) setPendingAudioDuration(savedProject.audioDuration);
    if (savedProject.audioSegments) setPendingAudioSegments(savedProject.audioSegments);
    if (savedProject.srtContent) setPendingSrtContent(savedProject.srtContent);
    if (savedProject.srtUrl) setPendingSrtUrl(savedProject.srtUrl);
    if (savedProject.imagePrompts) setImagePrompts(savedProject.imagePrompts);
    if (savedProject.imageUrls) setPendingImages(savedProject.imageUrls);
    if (savedProject.videoUrl) setVideoUrl(savedProject.videoUrl);
    if (savedProject.videoUrlCaptioned) setVideoUrlCaptioned(savedProject.videoUrlCaptioned);
    if (savedProject.embersVideoUrl) setEmbersVideoUrl(savedProject.embersVideoUrl);
    if (savedProject.smokeEmbersVideoUrl) setSmokeEmbersVideoUrl(savedProject.smokeEmbersVideoUrl);
    if (savedProject.thumbnails) setGeneratedThumbnails(savedProject.thumbnails);
    if (savedProject.selectedThumbnailIndex !== undefined) setSelectedThumbnailIndex(savedProject.selectedThumbnailIndex);
    if (savedProject.approvedSteps) setApprovedSteps(savedProject.approvedSteps);
    // Restore YouTube metadata
    if (savedProject.youtubeTitle) setYoutubeTitle(savedProject.youtubeTitle);
    if (savedProject.youtubeDescription) setYoutubeDescription(savedProject.youtubeDescription);
    if (savedProject.youtubeTags) setYoutubeTags(savedProject.youtubeTags);
    if (savedProject.youtubeCategoryId) setYoutubeCategoryId(savedProject.youtubeCategoryId);
    if (savedProject.youtubePlaylistId !== undefined) setYoutubePlaylistId(savedProject.youtubePlaylistId);

    // Build generated assets for results view (same logic as handleOpenProject)
    const assets: GeneratedAsset[] = [];
    if (savedProject.script) {
      assets.push({
        id: "script",
        name: "Rewritten Script",
        type: "Markdown",
        size: `${Math.round(savedProject.script.length / 1024)} KB`,
        icon: <FileText className="w-5 h-5 text-muted-foreground" />,
        content: savedProject.script,
      });
    }
    if (savedProject.audioUrl) {
      assets.push({
        id: "audio",
        name: "Voiceover Audio",
        type: "MP3",
        size: savedProject.audioDuration ? `${Math.round(savedProject.audioDuration / 60)} min` : "Unknown",
        icon: <Mic className="w-5 h-5 text-muted-foreground" />,
        url: savedProject.audioUrl,
      });
      setAudioUrl(savedProject.audioUrl);
    }
    if (savedProject.srtContent) {
      assets.push({
        id: "captions",
        name: "Captions",
        type: "SRT",
        size: `${Math.round(savedProject.srtContent.length / 1024)} KB`,
        icon: <FileText className="w-5 h-5 text-muted-foreground" />,
        url: savedProject.srtUrl,
        content: savedProject.srtContent,
      });
      setSrtContent(savedProject.srtContent);
    }
    if (savedProject.imageUrls) {
      savedProject.imageUrls.forEach((imageUrl, index) => {
        assets.push({
          id: `image-${index + 1}`,
          name: `Image ${index + 1}`,
          type: "PNG",
          size: "~1 MB",
          icon: <Image className="w-5 h-5 text-muted-foreground" />,
          url: imageUrl,
        });
      });
    }
    setGeneratedAssets(assets);

    // Go directly to results page
    setViewState("results");

    setSavedProject(null);
    toast({
      title: "Project Opened",
      description: `Loaded "${savedProject.videoTitle}"`,
    });
  };

  // Dismiss saved project banner - only archive if in_progress (not completed)
  const handleDismissSavedProject = () => {
    if (savedProject) {
      // Only archive in-progress projects when dismissed
      // Completed projects should stay accessible in the Projects drawer
      if (savedProject.status === 'in_progress') {
        console.log("[handleDismissSavedProject] Archiving in-progress project:", savedProject.id);
        archiveProject(savedProject.id).catch(err =>
          console.error('[handleDismissSavedProject] Failed to archive:', err)
        );
      } else {
        console.log("[handleDismissSavedProject] Dismissed completed project (not archiving):", savedProject.id);
      }
    }
    setSavedProject(null);
  };

  const toggleInputMode = () => {
    setInputMode(prev => prev === "url" ? "title" : "url");
    setInputValue("");
  };

  const handleSaveScriptTemplates = (templates: ScriptTemplate[]) => {
    setScriptTemplates(templates);
  };

  const handleSaveImageTemplates = (templates: ImageTemplate[]) => {
    setImageTemplates(templates);
    // Persist custom template overrides to localStorage
    saveCustomImageTemplates(templates);
  };

  const handleSaveVoices = (voices: CartesiaVoice[]) => {
    setCartesiaVoices(voices);
  };

  const updateStep = (stepId: string, status: "pending" | "active" | "completed", sublabel?: string) => {
    setProcessingSteps(prev => prev.map(step =>
      step.id === stepId
        ? { ...step, status, sublabel: sublabel || step.sublabel }
        : step
    ));
  };

  // Handler for selecting a video from the outlier finder
  const handleSelectOutlierVideo = (videoUrl: string, title: string) => {
    setInputValue(videoUrl);
    setInputMode("url");
    setSettings(prev => ({ ...prev, projectTitle: title }));
    setViewState("create");
  };

  // Step 1: Generate transcript and script
  const handleGenerate = async () => {
    // Check if using custom script (skip YouTube fetch and AI rewriting)
    const usingCustomScript = settings.customScript && settings.customScript.trim().length > 0;

    if (usingCustomScript) {
      // Using custom script - skip to audio generation
      if (!settings.voiceSampleUrl) {
        toast({
          title: "Voice Sample Required",
          description: "Please upload a voice sample for cloning in Settings.",
          variant: "destructive",
        });
        return;
      }

      // Set up project with custom script - ALWAYS new project from main page
      // CRITICAL: Reset all pending state FIRST to clear old project data
      resetPendingState();

      setSourceUrl("Custom Script");
      const useProjectId = crypto.randomUUID();
      setProjectId(useProjectId);
      const projectTitle = settings.projectTitle || "Custom Script";
      setVideoTitle(projectTitle);

      // Go straight to script review with custom script
      setPendingScript(settings.customScript!);

      // Auto-save the custom script project
      autoSave("script", {
        id: useProjectId,
        sourceUrl: "Custom Script",
        videoTitle: projectTitle,
        script: settings.customScript!
      });

      setViewState("review-script");
      return;
    }

    // Normal flow - validate inputs for YouTube/AI generation
    if (!inputValue.trim()) {
      toast({
        title: inputMode === "url" ? "URL Required" : "Title Required",
        description: inputMode === "url"
          ? "Please paste a YouTube URL to generate."
          : "Please enter a video title to generate.",
        variant: "destructive",
      });
      return;
    }

    // For title mode, require a project title in settings
    if (inputMode === "title" && !settings.projectTitle?.trim()) {
      toast({
        title: "Project Title Required",
        description: "Please enter a project title in Settings before generating.",
        variant: "destructive",
      });
      return;
    }

    if (inputMode === "url") {
      const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+/;
      if (!youtubeRegex.test(inputValue)) {
        toast({
          title: "Invalid URL",
          description: "Please enter a valid YouTube URL.",
          variant: "destructive",
        });
        return;
      }
    }

    const currentTemplate = scriptTemplates.find(t => t.id === settings.scriptTemplate);
    if (!currentTemplate?.template) {
      toast({
        title: "Template Required",
        description: "Please configure a script template in Settings.",
        variant: "destructive",
      });
      return;
    }

    if (!settings.voiceSampleUrl) {
      toast({
        title: "Voice Sample Required",
        description: "Please upload a voice sample for cloning in Settings.",
        variant: "destructive",
      });
      return;
    }

    // CRITICAL: Reset pending state FIRST to clear any old project data
    resetPendingState();

    setSourceUrl(inputValue);
    // ALWAYS generate a new projectId for new generations from the main page
    // This prevents overwriting existing project files when starting fresh
    const useProjectId = crypto.randomUUID();
    setProjectId(useProjectId);

    const steps: GenerationStep[] = [
      { id: "transcript", label: "Fetching YouTube Transcript", status: "pending" },
      { id: "script", label: "Rewriting Script", status: "pending" },
    ];

    setProcessingSteps(steps);
    setViewState("processing");

    try {
      updateStep("transcript", "active");
      const transcriptResult = await getYouTubeTranscript(inputValue);
      
      if (!transcriptResult.success || !transcriptResult.transcript) {
        throw new Error(transcriptResult.message || transcriptResult.error || "Failed to fetch transcript");
      }
      
      const transcript = transcriptResult.transcript;
      setVideoTitle(settings.projectTitle || transcriptResult.title || "History Documentary");
      updateStep("transcript", "completed");

      updateStep("script", "active", "0%");

      const scriptResult = await rewriteScriptStreaming(
        transcript,
        currentTemplate.template,
        transcriptResult.title || "History Documentary",
        settings.aiModel,
        settings.wordCount,
        (progress, wordCount) => {
          // Show only progress percentage and word count (no script preview)
          const progressText = `${progress}% (${wordCount.toLocaleString()} words)`;
          updateStep("script", "active", progressText);
        }
      );
      
      if (!scriptResult.success || !scriptResult.script) {
        throw new Error(scriptResult.error || "Failed to rewrite script");
      }
      
      updateStep("script", "completed");
      setPendingScript(scriptResult.script);

      // Auto-save after script generation (pass useProjectId since state hasn't updated yet)
      autoSave("script", {
        id: useProjectId,
        sourceUrl: inputValue,
        videoTitle: settings.projectTitle || transcriptResult.title || "History Documentary",
        script: scriptResult.script
      });

      await new Promise(resolve => setTimeout(resolve, 300));
      setViewState("review-script");

    } catch (error) {
      console.error("Generation error:", error);
      toast({
        title: "Generation Failed",
        description: error instanceof Error ? error.message : "An error occurred during generation.",
        variant: "destructive",
      });
      setViewState("create");
    }
  };

  // Step 2: After script confirmed, generate audio (6 segments)
  const handleScriptConfirm = async (script: string) => {
    // Update both pending and confirmed script so edits persist when navigating back
    setPendingScript(script);
    setConfirmedScript(script);

    const steps: GenerationStep[] = [
      { id: "audio", label: "Generating Audio", status: "pending" },
    ];

    setProcessingSteps(steps);
    setViewState("processing");

    try {
      await saveScriptToStorage(script, projectId);

      updateStep("audio", "active", "0%");
      const audioRes = await generateAudioStreaming(
        script,
        settings.voiceSampleUrl!,
        projectId,
        (progress) => {
          updateStep("audio", "active", `${progress}%`);
        },
        settings.speed,
        {
          emotionMarker: settings.ttsEmotionMarker,
          temperature: settings.ttsTemperature,
          topP: settings.ttsTopP,
          repetitionPenalty: settings.ttsRepetitionPenalty,
        }
      );

      if (!audioRes.success) {
        throw new Error(audioRes.error || "Failed to generate audio");
      }

      updateStep("audio", "completed", "100%");

      // Handle audio response - prefer combined audioUrl for captions
      if (audioRes.audioUrl) {
        // Use combined audio URL for playback and captions
        setPendingAudioUrl(audioRes.audioUrl);
        setPendingAudioDuration(audioRes.duration || audioRes.totalDuration || 0);
        setPendingAudioSize(audioRes.size || 0);
        // Store segments for individual regeneration if available
        if (audioRes.segments && audioRes.segments.length > 0) {
          setPendingAudioSegments(audioRes.segments);
        } else {
          setPendingAudioSegments([]);
        }
      } else if (audioRes.segments && audioRes.segments.length > 0) {
        // Fallback: no combined URL, use first segment (shouldn't happen with new backend)
        console.warn("No combined audioUrl, falling back to first segment");
        setPendingAudioSegments(audioRes.segments);
        setPendingAudioDuration(audioRes.totalDuration || 0);
        const totalSize = audioRes.segments.reduce((sum, seg) => sum + seg.size, 0);
        setPendingAudioSize(totalSize);
        setPendingAudioUrl(audioRes.segments[0].audioUrl);
      } else {
        throw new Error("No audio generated");
      }

      // Auto-save after audio generation
      autoSave("audio", {
        audioUrl: audioRes.audioUrl || (audioRes.segments?.[0]?.audioUrl),
        audioDuration: audioRes.duration || audioRes.totalDuration || 0,
        audioSegments: audioRes.segments || [],
      });

      await new Promise(resolve => setTimeout(resolve, 300));
      setViewState("review-audio");

    } catch (error) {
      console.error("Audio generation error:", error);
      toast({
        title: "Audio Generation Failed",
        description: error instanceof Error ? error.message : "An error occurred.",
        variant: "destructive",
      });
      setViewState("create");
    }
  };

  // Regenerate audio (all segments)
  const handleAudioRegenerate = () => {
    handleScriptConfirm(confirmedScript);
  };

  // Regenerate a single audio segment
  const handleSegmentRegenerate = async (segmentIndex: number, editedText?: string) => {
    const segment = pendingAudioSegments.find(s => s.index === segmentIndex);
    if (!segment) {
      toast({
        title: "Error",
        description: "Segment not found",
        variant: "destructive",
      });
      return;
    }

    setRegeneratingSegmentIndex(segmentIndex);

    // Use edited text if provided, otherwise use original segment text
    const textToUse = editedText || segment.text;

    try {
      console.log(`Regenerating segment ${segmentIndex}${editedText ? ' with edited text' : ''}...`);

      const result = await regenerateAudioSegment(
        textToUse,
        segmentIndex,
        settings.voiceSampleUrl!,
        projectId
      );

      if (!result.success || !result.segment) {
        throw new Error(result.error || "Failed to regenerate segment");
      }

      // Update the segment in the array (include new text if it was edited)
      setPendingAudioSegments(prev => {
        const newSegments = [...prev];
        const idx = newSegments.findIndex(s => s.index === segmentIndex);
        if (idx !== -1) {
          newSegments[idx] = {
            ...result.segment!,
            text: textToUse // Preserve the edited text in the segment
          };
        }
        return newSegments;
      });

      // Recalculate totals
      const newTotalDuration = pendingAudioSegments.reduce((sum, seg) => {
        if (seg.index === segmentIndex) {
          return sum + result.segment!.duration;
        }
        return sum + seg.duration;
      }, 0);
      setPendingAudioDuration(newTotalDuration);

      // Mark that combined audio needs to be recombined before generating captions
      setSegmentsNeedRecombine(true);

      toast({
        title: "Segment Regenerated",
        description: `Segment ${segmentIndex} has been regenerated. Click "Confirm Audio" to update captions.`,
      });

    } catch (error) {
      console.error("Segment regeneration error:", error);
      toast({
        title: "Regeneration Failed",
        description: error instanceof Error ? error.message : "Failed to regenerate segment",
        variant: "destructive",
      });
    } finally {
      setRegeneratingSegmentIndex(null);
    }
  };

  // Skip captions and go directly to image prompts
  const handleSkipCaptions = async () => {
    // Use script text as fallback for captions (for timing, prompts will be evenly distributed)
    const scriptAsSrt = confirmedScript || pendingScript || "";

    // Create a simple SRT from script (single segment spanning full duration)
    const duration = pendingAudioDuration || 60;
    const formatTime = (seconds: number) => {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      const ms = Math.floor((seconds % 1) * 1000);
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
    };

    const simpleSrt = `1\n${formatTime(0)} --> ${formatTime(duration)}\n${scriptAsSrt.substring(0, 500)}...\n`;

    setPendingSrtContent(simpleSrt);

    // Auto-save and go to prompts
    autoSave("captions", { srtContent: simpleSrt });

    // Call the captions confirm handler with the script as SRT
    await handleCaptionsConfirm(simpleSrt);
  };

  // Step 3: After audio confirmed, generate captions (for image timing) then go to image prompts
  const handleAudioConfirm = async () => {
    const steps: GenerationStep[] = [];

    // Add recombine step if segments were modified
    if (segmentsNeedRecombine) {
      steps.push({ id: "recombine", label: "Recombining audio segments", status: "pending" });
    }

    // Always add captions step (for accurate image timing)
    steps.push({ id: "captions", label: "Transcribing audio for image timing", status: "pending" });

    setProcessingSteps(steps);
    setViewState("processing");

    try {
      let audioUrlToUse = pendingAudioUrl;

      // Recombine segments if any were regenerated
      if (segmentsNeedRecombine) {
        updateStep("recombine", "active");
        console.log("Recombining audio segments...");

        const recombineResult = await recombineAudioSegments(projectId, pendingAudioSegments.length);

        if (!recombineResult.success || !recombineResult.audioUrl) {
          throw new Error(recombineResult.error || "Failed to recombine audio segments");
        }

        audioUrlToUse = recombineResult.audioUrl;
        setPendingAudioUrl(audioUrlToUse);
        if (recombineResult.duration) setPendingAudioDuration(recombineResult.duration);
        if (recombineResult.size) setPendingAudioSize(recombineResult.size);
        setSegmentsNeedRecombine(false);

        updateStep("recombine", "completed");
        console.log(`Recombined audio: ${audioUrlToUse}`);
      }

      // Generate captions automatically (for accurate image timing)
      updateStep("captions", "active", "Transcribing audio...");
      console.log("Generating captions for image timing...");

      const captionsResult = await generateCaptions(
        audioUrlToUse,
        projectId,
        (progress, message) => {
          updateStep("captions", "active", message || `Transcribing... ${progress}%`);
        }
      );

      if (!captionsResult.success || !captionsResult.srtContent) {
        // Fall back to evenly distributed timing if captions fail
        console.warn("Captions generation failed, using even distribution:", captionsResult.error);
        updateStep("captions", "completed", "Using even distribution");
        await handleSkipCaptions();
        return;
      }

      updateStep("captions", "completed", "Transcription complete");
      console.log("Captions generated successfully");

      // Use the real SRT for image timing
      setPendingSrtContent(captionsResult.srtContent);
      autoSave("captions", { srtContent: captionsResult.srtContent });

      // Show captions preview modal for user to review and set image settings
      setViewState("review-captions");

    } catch (error) {
      console.error("Audio confirm error:", error);
      toast({
        title: "Audio Processing Failed",
        description: error instanceof Error ? error.message : "An error occurred.",
        variant: "destructive",
      });
      setViewState("create");
    }
  };

  // Step 4: After captions confirmed, generate image prompts for review
  const handleCaptionsConfirm = async (srt: string) => {
    setPendingSrtContent(srt);

    // Auto-save captions immediately
    autoSave("captions", { srtContent: srt });

    const steps: GenerationStep[] = [
      { id: "prompts", label: "Generating Scene Descriptions", status: "pending" },
    ];

    setProcessingSteps(steps);
    setViewState("processing");

    try {
      updateStep("prompts", "active", "Analyzing script...");

      // Use confirmedScript if available, otherwise extract text from captions
      // This handles the "Generate Captions" flow where user uploads audio without a script
      let scriptForPrompts = confirmedScript;
      if (!scriptForPrompts.trim()) {
        // Extract plain text from SRT captions
        const srtLines = srt.split('\n');
        const textLines: string[] = [];
        for (let i = 0; i < srtLines.length; i++) {
          const line = srtLines[i].trim();
          // Skip empty lines, numbers, and timecodes
          if (line && !line.match(/^\d+$/) && !line.includes('-->')) {
            textLines.push(line);
          }
        }
        scriptForPrompts = textLines.join(' ');
        console.log('No script available, using captions text for image prompts');
      }

      const promptResult = await generateImagePrompts(
        scriptForPrompts,
        srt,
        settings.imageCount,
        getSelectedImageStyle(),
        pendingAudioDuration,
        (progress, message) => {
          updateStep("prompts", "active", message);
        }
      );

      if (!promptResult.success || !promptResult.prompts) {
        throw new Error(promptResult.error || "Failed to generate image prompts");
      }

      console.log(`Generated ${promptResult.prompts.length} AI-powered image prompts with timing`);
      setImagePrompts(promptResult.prompts);
      updateStep("prompts", "completed", `${promptResult.prompts.length} scenes`);

      // Auto-save after image prompts generation
      autoSave("prompts", { imagePrompts: promptResult.prompts });

      await new Promise(resolve => setTimeout(resolve, 300));
      setViewState("review-prompts");

    } catch (error) {
      console.error("Image prompt generation error:", error);
      toast({
        title: "Prompt Generation Failed",
        description: error instanceof Error ? error.message : "An error occurred.",
        variant: "destructive",
      });
      setViewState("create");
    }
  };

  // Step 5: After prompts reviewed/edited, generate images
  const handlePromptsConfirm = async (editedPrompts: ImagePromptWithTiming[], editedStylePrompt: string) => {
    setImagePrompts(editedPrompts);
    // editedStylePrompt is used directly for this generation (not saved back to template)

    const steps: GenerationStep[] = [
      { id: "images", label: "Generating Images", status: "pending" },
    ];

    setProcessingSteps(steps);
    setViewState("processing");

    try {
      updateStep("images", "active", `0/${editedPrompts.length}`);

      const imageResult = await generateImagesStreaming(
        editedPrompts,
        settings.quality,
        "16:9",
        (completed, total) => {
          updateStep("images", "active", `${completed}/${total}`);
        },
        projectId
      );

      if (!imageResult.success) {
        console.error('Image generation failed:', imageResult.error);
        toast({
          title: "Image Generation Issue",
          description: imageResult.error || "Some images may not have generated",
          variant: "destructive",
        });
      }

      updateStep("images", "completed", "Done");
      setPendingImages(imageResult.images || []);

      // Auto-save after images generation
      autoSave("images", { imageUrls: imageResult.images || [] });

      await new Promise(resolve => setTimeout(resolve, 300));
      setViewState("review-images");

    } catch (error) {
      console.error("Image generation error:", error);
      toast({
        title: "Image Generation Failed",
        description: error instanceof Error ? error.message : "An error occurred.",
        variant: "destructive",
      });
      setViewState("create");
    }
  };

  // Regenerate a single image (optionally with edited prompt)
  const handleRegenerateImage = async (index: number, editedSceneDescription?: string) => {
    if (!imagePrompts[index]) {
      toast({
        title: "Error",
        description: "Image prompt not found",
        variant: "destructive",
      });
      return;
    }

    setRegeneratingImageIndex(index);

    try {
      // If edited prompt provided, update the imagePrompts state first
      let promptToUse = imagePrompts[index];
      if (editedSceneDescription) {
        promptToUse = {
          ...imagePrompts[index],
          sceneDescription: editedSceneDescription,
          prompt: imagePrompts[index].prompt.replace(imagePrompts[index].sceneDescription, editedSceneDescription)
        };
        // Update the prompts state with the edited version
        setImagePrompts(prev => {
          const newPrompts = [...prev];
          newPrompts[index] = promptToUse;
          return newPrompts;
        });
      }

      console.log(`Regenerating image ${index + 1}${editedSceneDescription ? ' with edited prompt' : ''}...`);

      const imageResult = await generateImagesStreaming(
        [promptToUse], // Regenerate just this one prompt with timing
        settings.quality,
        "16:9",
        () => {}, // No progress callback needed for single image
        projectId
      );

      if (!imageResult.success || !imageResult.images || imageResult.images.length === 0) {
        throw new Error(imageResult.error || 'Failed to regenerate image');
      }

      // Update the image at the specific index
      setPendingImages(prev => {
        const newImages = [...prev];
        newImages[index] = imageResult.images![0];
        return newImages;
      });

      toast({
        title: "Image Regenerated",
        description: `Image ${index + 1} has been regenerated successfully.`,
      });

    } catch (error) {
      console.error("Image regeneration error:", error);
      toast({
        title: "Regeneration Failed",
        description: error instanceof Error ? error.message : "Failed to regenerate image",
        variant: "destructive",
      });
    } finally {
      setRegeneratingImageIndex(undefined);
    }
  };

  // Regenerate multiple images in parallel (with optional edited prompts)
  const handleRegenerateMultipleImages = async (indices: number[], editedPrompts?: Map<number, string>) => {
    if (indices.length === 0) return;

    // Set all indices as regenerating
    setRegeneratingImageIndices(new Set(indices));

    const MAX_CONCURRENT = 4; // Match RunPod worker limit

    try {
      // Process in batches of MAX_CONCURRENT
      for (let i = 0; i < indices.length; i += MAX_CONCURRENT) {
        const batch = indices.slice(i, i + MAX_CONCURRENT);

        await Promise.all(batch.map(async (index) => {
          if (!imagePrompts[index]) return;

          // Get prompt (use edited version if provided)
          let promptToUse = imagePrompts[index];
          const editedDescription = editedPrompts?.get(index);

          if (editedDescription) {
            promptToUse = {
              ...imagePrompts[index],
              sceneDescription: editedDescription,
              prompt: imagePrompts[index].prompt.replace(imagePrompts[index].sceneDescription, editedDescription)
            };
            // Update the prompts state with the edited version
            setImagePrompts(prev => {
              const newPrompts = [...prev];
              newPrompts[index] = promptToUse;
              return newPrompts;
            });
          }

          try {
            const imageResult = await generateImagesStreaming(
              [promptToUse],
              settings.quality,
              "16:9",
              () => {},
              projectId
            );

            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              // Update the image at the specific index
              setPendingImages(prev => {
                const newImages = [...prev];
                newImages[index] = imageResult.images![0];
                return newImages;
              });
            }
          } catch (error) {
            console.error(`Failed to regenerate image ${index + 1}:`, error);
          } finally {
            // Remove this index from regenerating set
            setRegeneratingImageIndices(prev => {
              const next = new Set(prev);
              next.delete(index);
              return next;
            });
          }
        }));
      }

      toast({
        title: "Images Regenerated",
        description: `${indices.length} images have been regenerated.`,
      });

    } catch (error) {
      console.error("Batch regeneration error:", error);
      toast({
        title: "Regeneration Failed",
        description: error instanceof Error ? error.message : "Failed to regenerate images",
        variant: "destructive",
      });
    } finally {
      setRegeneratingImageIndices(new Set());
    }
  };

  // Step 5: Complete - show results
  const handleImagesConfirmWithImages = (images: string[]) => {
    const assets: GeneratedAsset[] = [
      {
        id: "script",
        name: "Rewritten Script",
        type: "Markdown",
        size: `${Math.round(confirmedScript.length / 1024)} KB`,
        icon: <FileText className="w-5 h-5 text-muted-foreground" />,
        content: confirmedScript,
      },
      {
        id: "audio",
        name: "Voiceover Audio",
        type: "MP3",
        size: pendingAudioSize ? `${(pendingAudioSize / (1024 * 1024)).toFixed(1)} MB` : "Unknown",
        icon: <Mic className="w-5 h-5 text-muted-foreground" />,
        url: pendingAudioUrl,
      },
      {
        id: "captions",
        name: "Captions",
        type: "SRT",
        size: pendingSrtContent ? `${Math.round(pendingSrtContent.length / 1024)} KB` : "Unknown",
        icon: <FileText className="w-5 h-5 text-muted-foreground" />,
        url: pendingSrtUrl,
        content: pendingSrtContent,
      },
    ];

    images.forEach((imageUrl, index) => {
      assets.push({
        id: `image-${index + 1}`,
        name: `Image ${index + 1}`,
        type: "PNG",
        size: "~1 MB",
        icon: <Image className="w-5 h-5 text-muted-foreground" />,
        url: imageUrl,
      });
    });

    setGeneratedAssets(assets);
    setAudioUrl(pendingAudioUrl);
    setSrtContent(pendingSrtContent);
    setViewState("results");

    // Mark project as completed in the unified store
    // No clearProject needed - just change status
    console.log("[finishGeneration] Marking project as completed:", projectId);
    completeProject(projectId).catch(err =>
      console.error('[finishGeneration] Failed to complete project:', err)
    );

    toast({
      title: "Generation Complete!",
      description: "Your history video assets are ready.",
    });
  };

  const handleImagesConfirm = () => {
    // Go to video render step (no effects)
    setViewState("review-render");
  };

  // Thumbnail handlers
  const handleThumbnailsConfirm = (thumbnails: string[], selectedIndex: number | undefined) => {
    setGeneratedThumbnails(thumbnails);
    setSelectedThumbnailIndex(selectedIndex);
    // Save thumbnails to project
    autoSave("complete", {
      thumbnails,
      selectedThumbnailIndex: selectedIndex,
    });
    // Go to YouTube upload step
    setViewState("review-youtube");
  };

  const handleThumbnailsSkip = () => {
    setGeneratedThumbnails([]);
    setSelectedThumbnailIndex(undefined);
    // Go to YouTube upload step
    setViewState("review-youtube");
  };

  // Favorite thumbnail toggle
  const handleFavoriteThumbnailToggle = (url: string) => {
    setFavoriteThumbnails(prev => {
      const newFavorites = prev.includes(url)
        ? prev.filter(u => u !== url)
        : [...prev, url];
      // Persist to localStorage
      localStorage.setItem('historygenai-favorite-thumbnails', JSON.stringify(newFavorites));
      return newFavorites;
    });
  };

  // Video render handlers (basic video without effects)
  const handleRenderConfirm = (videoUrlBasic: string) => {
    // Save the basic video URL
    setVideoUrl(videoUrlBasic);
    autoSave("complete", { videoUrl: videoUrlBasic });
    // Go to visual effects step
    setViewState("review-effects");
  };

  const handleRenderSkip = () => {
    // Skip to visual effects (can render effects without basic)
    setViewState("review-effects");
  };

  const handleBackToImages = () => {
    setSettings(prev => ({ ...prev, fullAutomation: false }));
    setViewState("review-images");
  };

  // Visual effects handlers (smoke + embers)
  const handleEffectsConfirm = (videoUrlWithEffects: string) => {
    // Save the rendered video with effects
    setRenderedVideoUrl(videoUrlWithEffects);
    setSmokeEmbersVideoUrl(videoUrlWithEffects);
    autoSave("complete", { smokeEmbersVideoUrl: videoUrlWithEffects });
    // Go to thumbnails step
    setViewState("review-thumbnails");
  };

  const handleEffectsSkip = () => {
    // Skip to thumbnails without effects video
    setViewState("review-thumbnails");
  };

  const handleBackToRender = () => {
    setSettings(prev => ({ ...prev, fullAutomation: false }));
    setViewState("review-render");
  };

  const handleBackToEffects = () => {
    setSettings(prev => ({ ...prev, fullAutomation: false }));
    setViewState("review-effects");
  };

  const handleBackToThumbnails = () => {
    setSettings(prev => ({ ...prev, fullAutomation: false }));
    setViewState("review-thumbnails");
  };

  // YouTube upload handlers
  const handleYouTubeComplete = () => {
    // Go to results
    handleImagesConfirmWithImages(pendingImages);
  };

  const handleYouTubeSkip = () => {
    // Go to results
    handleImagesConfirmWithImages(pendingImages);
  };

  const resetPendingState = () => {
    // CRITICAL: Reset projectId to ensure new projects get new UUIDs
    // This prevents overwriting existing project files
    setProjectId("");
    setGeneratedAssets([]);
    setAudioUrl(undefined);
    setSrtContent(undefined);
    setPendingScript("");
    setConfirmedScript("");
    setPendingAudioUrl("");
    setPendingAudioDuration(0);
    setPendingAudioSize(0);
    setPendingAudioSegments([]);
    setRegeneratingSegmentIndex(null);
    setPendingSrtContent("");
    setPendingSrtUrl("");
    setPendingImages([]);
    setGeneratedThumbnails([]);
    setRenderedVideoUrl(undefined);
    setVideoUrl(undefined);
    setVideoUrlCaptioned(undefined);
    setEmbersVideoUrl(undefined);
    setSmokeEmbersVideoUrl(undefined);
    setImagePrompts([]);
  };

  const handleCancelRequest = () => {
    // Auto-save is always enabled, so no confirmation needed
    // If we have a loaded project, go back to results without resetting assets
    // Otherwise reset everything and go to create page
    if (generatedAssets.length > 0) {
      setViewState("results");
    } else {
      resetPendingState();
      setViewState("create");
    }
  };

  // Back navigation handlers - disable fullAutomation when manually navigating back
  const disableAutoAndGoTo = (view: ViewState) => {
    setSettings(prev => ({ ...prev, fullAutomation: false }));
    setViewState(view);
  };

  const handleBackToCreate = () => {
    disableAutoAndGoTo("create");
  };

  const handleBackToScript = () => {
    disableAutoAndGoTo("review-script");
  };

  // Regenerate script with AI fix prompt
  const handleScriptRegenerate = async (fixPrompt: string) => {
    const currentTemplate = scriptTemplates.find(t => t.id === settings.scriptTemplate);
    if (!currentTemplate?.template) {
      toast({
        title: "Template Missing",
        description: "No script template found for regeneration.",
        variant: "destructive",
      });
      return;
    }

    // Append fix instructions to template
    const modifiedTemplate = `${currentTemplate.template}

CRITICAL FIX REQUIRED:
${fixPrompt}

Please regenerate the script with these issues fixed.`;

    setViewState("processing");
    setProcessingSteps([
      { id: "script", label: "Regenerating Script", status: "active", sublabel: "0%" }
    ]);

    try {
      const scriptResult = await rewriteScriptStreaming(
        pendingScript, // Use current script as basis
        modifiedTemplate,
        videoTitle || "History Documentary",
        settings.aiModel,
        settings.wordCount,
        (progress) => {
          setProcessingSteps([
            { id: "script", label: "Regenerating Script", status: "active", sublabel: `${progress}%` }
          ]);
        }
      );

      if (!scriptResult.success || !scriptResult.script) {
        throw new Error(scriptResult.error || "Failed to regenerate script");
      }

      setPendingScript(scriptResult.script);

      // Auto-save the regenerated script
      if (projectId) {
        autoSave("script", {
          id: projectId,
          script: scriptResult.script
        });
      }

      toast({
        title: "Script Regenerated",
        description: "The script has been updated with fixes. Please review.",
      });

      setViewState("review-script");
    } catch (error) {
      console.error("Script regeneration error:", error);
      toast({
        title: "Regeneration Failed",
        description: error instanceof Error ? error.message : "Failed to regenerate script",
        variant: "destructive",
      });
      setViewState("review-script"); // Go back to review with original script
    }
  };

  const handleBackToAudio = () => {
    disableAutoAndGoTo("review-audio");
  };

  const handleBackToCaptions = () => {
    disableAutoAndGoTo("review-captions");
  };

  const handleBackToPrompts = () => {
    disableAutoAndGoTo("review-prompts");
  };

  // Forward navigation handlers (to skip ahead if data already exists)
  // These disable fullAutomation because user is manually navigating
  const handleForwardToAudio = () => {
    if (pendingAudioUrl || pendingAudioSegments.length > 0) {
      disableAutoAndGoTo("review-audio");
    }
  };

  const handleForwardToCaptions = () => {
    if (pendingSrtContent) {
      disableAutoAndGoTo("review-captions");
    }
  };

  const handleForwardToPrompts = () => {
    if (imagePrompts.length > 0) {
      disableAutoAndGoTo("review-prompts");
    }
  };

  const handleForwardToImages = () => {
    if (pendingImages.length > 0) {
      disableAutoAndGoTo("review-images");
    }
  };

  // Check if forward navigation is available for each step
  const canGoForwardFromScript = () => pendingAudioUrl || pendingAudioSegments.length > 0;
  const canGoForwardFromAudio = () => !!pendingSrtContent;
  const canGoForwardFromCaptions = () => imagePrompts.length > 0;
  const canGoForwardFromPrompts = () => pendingImages.length > 0;

  // Handle pipeline step approval
  const handleApproveStep = (step: PipelineStep, approved: boolean) => {
    setApprovedSteps(prev => {
      if (approved) {
        // Add step if not already approved
        return prev.includes(step) ? prev : [...prev, step];
      } else {
        // Remove step from approved list
        return prev.filter(s => s !== step);
      }
    });
    // Save approval to project
    const newApprovedSteps = approved
      ? (approvedSteps.includes(step) ? approvedSteps : [...approvedSteps, step])
      : approvedSteps.filter(s => s !== step);
    autoSave("complete", { approvedSteps: newApprovedSteps });
  };

  // Save a version of the current project
  const handleSaveVersion = async () => {
    if (!projectId) {
      toast({
        title: "No Project",
        description: "No project to save a version of.",
        variant: "destructive",
      });
      return;
    }

    try {
      const newVersionId = await createProjectVersion(projectId);
      toast({
        title: "Version Saved",
        description: `Saved version of "${videoTitle}"`,
      });
      console.log(`[handleSaveVersion] Created version ${newVersionId} for project ${projectId}`);
    } catch (error) {
      console.error('[handleSaveVersion] Error:', error);
      toast({
        title: "Save Failed",
        description: "Failed to save version.",
        variant: "destructive",
      });
    }
  };

  // Duplicate the current project as an independent copy
  const handleDuplicate = async () => {
    if (!projectId) {
      toast({
        title: "No Project",
        description: "No project to duplicate.",
        variant: "destructive",
      });
      return;
    }

    try {
      const newId = await duplicateProject(projectId);
      toast({
        title: "Project Duplicated",
        description: `Created copy of "${videoTitle}"`,
      });
      console.log(`[handleDuplicate] Duplicated project ${projectId} as ${newId}`);
      // Optionally navigate to the new project - for now just show success
    } catch (error) {
      console.error('[handleDuplicate] Error:', error);
      toast({
        title: "Duplicate Failed",
        description: "Failed to duplicate project.",
        variant: "destructive",
      });
    }
  };

  // Handle audio file upload for "Generate Captions" mode
  const handleAudioFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setUploadedAudioFile(file);
    }
  };

  // Handle script file upload for "Generate Images" mode
  const handleScriptFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const text = await file.text();
      setUploadedScript(text);
    }
  };

  // Handle captions file upload for "Generate Images" mode
  const handleCaptionsFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const text = await file.text();
      setUploadedCaptions(text);
    }
  };

  // Handle audio file upload for "Generate Images" mode
  const handleAudioFileChangeForImages = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setUploadedAudioFileForImages(file);
    }
  };

  // Generate captions from uploaded audio file
  const handleGenerateCaptionsFromAudio = async () => {
    if (!uploadedAudioFile) {
      toast({ title: "No audio file", description: "Please upload an audio file first.", variant: "destructive" });
      return;
    }

    // CRITICAL: Reset all pending state FIRST to clear old project data
    resetPendingState();

    // Set project title
    const title = captionsProjectTitle.trim() || "Untitled Project";
    setVideoTitle(title);

    setViewState("processing");
    setProcessingSteps([{ id: "upload", label: "Uploading audio", status: "active", sublabel: "0%" }]);

    try {
      // Upload the audio file to Supabase storage with progress tracking
      // ALWAYS new project from main page caption mode
      const useProjectId = crypto.randomUUID();
      setProjectId(useProjectId);
      const audioFileName = `${useProjectId}/voiceover.wav`;

      // Use XMLHttpRequest for upload progress
      const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
      const supabaseKey = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;
      const uploadUrl = `${supabaseUrl}/storage/v1/object/generated-assets/${audioFileName}`;

      await new Promise<void>((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', uploadUrl, true);
        xhr.setRequestHeader('Authorization', `Bearer ${supabaseKey}`);
        xhr.setRequestHeader('apikey', supabaseKey);
        xhr.setRequestHeader('x-upsert', 'true');

        xhr.upload.onprogress = (event) => {
          if (event.lengthComputable) {
            const percent = Math.round((event.loaded / event.total) * 100);
            setProcessingSteps([{ id: "upload", label: "Uploading audio", status: "active", sublabel: `${percent}%` }]);
          }
        };

        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve();
          } else {
            reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));
          }
        };

        xhr.onerror = () => reject(new Error('Upload failed'));
        xhr.send(uploadedAudioFile);
      });

      const { data: { publicUrl } } = supabase.storage
        .from("generated-assets")
        .getPublicUrl(audioFileName);

      setPendingAudioUrl(publicUrl);

      // Update to show captions step
      setProcessingSteps([
        { id: "upload", label: "Uploading audio", status: "completed" },
        { id: "captions", label: "Generating captions", status: "active", sublabel: "5%" }
      ]);

      // Generate captions
      const captionsResult = await generateCaptions(
        publicUrl,
        useProjectId,
        (progress, message) => {
          const sublabel = message || `${progress}%`;
          setProcessingSteps([
            { id: "upload", label: "Uploading audio", status: "completed" },
            { id: "captions", label: "Generating captions", status: "active", sublabel }
          ]);
        }
      );

      if (!captionsResult.srtContent) throw new Error("No captions generated");

      setPendingSrtContent(captionsResult.srtContent);
      if (captionsResult.srtUrl) setPendingSrtUrl(captionsResult.srtUrl);
      if (captionsResult.audioDuration) setPendingAudioDuration(captionsResult.audioDuration);

      // Auto-save after captions generation
      autoSave("captions", {
        id: useProjectId,
        videoTitle: title,
        audioUrl: publicUrl,
        audioDuration: captionsResult.audioDuration,
        srtContent: captionsResult.srtContent,
        srtUrl: captionsResult.captionsUrl || "",
      });

      setProcessingSteps([
        { id: "upload", label: "Uploading audio", status: "completed" },
        { id: "captions", label: "Captions generated", status: "completed" }
      ]);
      setViewState("review-captions");

    } catch (error) {
      console.error("Error generating captions:", error);
      toast({ title: "Error", description: error instanceof Error ? error.message : "Failed to generate captions", variant: "destructive" });
      setViewState("create");
    }
  };

  // Generate image prompts from uploaded script/captions
  const handleGenerateImagePrompts = async () => {
    const scriptText = uploadedScript.trim();
    const captionsText = uploadedCaptions.trim();

    console.log("Script length:", scriptText.length);
    console.log("Captions length:", captionsText.length);
    console.log("Image count:", settings.imageCount);
    console.log("Style prompt length:", getSelectedImageStyle().length);
    console.log("Audio file:", uploadedAudioFileForImages?.name);

    if (!scriptText) {
      toast({ title: "No script", description: "Please upload or paste a script first.", variant: "destructive" });
      return;
    }
    if (!captionsText) {
      toast({ title: "No captions", description: "Please upload or paste captions (SRT) first.", variant: "destructive" });
      return;
    }

    // CRITICAL: Reset all pending state FIRST to clear old project data
    resetPendingState();

    // Set project title
    const title = imagesProjectTitle.trim() || "Untitled Project";
    setVideoTitle(title);

    // ALWAYS generate new projectId for new entries from main page images mode
    const useProjectId = crypto.randomUUID();
    setProjectId(useProjectId);

    setViewState("processing");
    setProcessingSteps([{ id: "prompts", label: "Generating image prompts...", status: "loading", progress: 10 }]);
    setPendingScript(scriptText);
    setConfirmedScript(scriptText);
    setPendingSrtContent(captionsText);

    try {
      let audioDuration: number | undefined;

      // If audio file provided, upload it and get duration
      if (uploadedAudioFileForImages) {
        setProcessingSteps([{ id: "prompts", label: "Uploading audio file...", status: "loading", progress: 5 }]);

        const audioFileName = `${useProjectId}/voiceover.wav`;
        const { error: uploadError } = await supabase.storage
          .from("generated-assets")
          .upload(audioFileName, uploadedAudioFileForImages);

        if (uploadError) {
          console.error("Audio upload error:", uploadError);
          // Continue without audio duration if upload fails
        } else {
          const { data: { publicUrl } } = supabase.storage
            .from("generated-assets")
            .getPublicUrl(audioFileName);

          setPendingAudioUrl(publicUrl);

          // Get audio duration using Audio element
          audioDuration = await new Promise<number>((resolve) => {
            const audio = new Audio(publicUrl);
            audio.addEventListener('loadedmetadata', () => {
              resolve(audio.duration);
            });
            audio.addEventListener('error', () => {
              console.error("Failed to get audio duration");
              resolve(0);
            });
          });

          if (audioDuration > 0) {
            setPendingAudioDuration(audioDuration);
            console.log("Audio duration:", audioDuration);
          }
        }

        setProcessingSteps([{ id: "prompts", label: "Generating image prompts...", status: "loading", progress: 10 }]);
      }

      const promptsResult = await generateImagePrompts(
        scriptText,
        captionsText,
        settings.imageCount,
        getSelectedImageStyle(),
        audioDuration
      );

      if (!promptsResult.success) {
        throw new Error(promptsResult.error || "Failed to generate image prompts");
      }

      if (!promptsResult.prompts || promptsResult.prompts.length === 0) {
        throw new Error("No image prompts generated");
      }

      setImagePrompts(promptsResult.prompts);

      // Auto-save after image prompts generation (projectId was set at start of this handler)
      autoSave("prompts", {
        id: useProjectId,
        videoTitle: title,
        script: scriptText,
        srtContent: captionsText,
        audioUrl: pendingAudioUrl,
        audioDuration: audioDuration || pendingAudioDuration,
        imagePrompts: promptsResult.prompts,
      });

      setProcessingSteps([{ id: "prompts", label: "Image prompts generated", status: "complete", progress: 100 }]);
      setViewState("review-prompts");

    } catch (error) {
      console.error("Error generating image prompts:", error);
      toast({ title: "Error", description: error instanceof Error ? error.message : "Failed to generate image prompts", variant: "destructive" });
      setViewState("create");
    }
  };

  const handleNewProject = () => {
    console.log("[handleNewProject] User clicked New Project from results page");
    setViewState("create");
    setInputValue("");
    setSourceUrl("");
    setVideoTitle("History Documentary"); // Reset to default title
    resetPendingState(); // This also resets projectId to "" so new project gets new UUID
    setApprovedSteps([]);  // Clear approvals for new project
    // No clearProject needed - new project will be a new entry in the store
  };

  // Open a project from history
  // Helper to reconstruct audio segments from storage for old projects
  const reconstructAudioSegments = async (projectId: string, script: string): Promise<AudioSegment[]> => {
    const segments: AudioSegment[] = [];
    const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;

    // Try to find segment files (1-10)
    for (let i = 1; i <= 10; i++) {
      const segmentPath = `${projectId}/voiceover-segment-${i}.wav`;
      const { data } = await supabase.storage
        .from('generated-assets')
        .createSignedUrl(segmentPath, 3600);

      if (data?.signedUrl) {
        // Split script into roughly equal parts for text approximation
        const scriptParts = script.split(/[.!?]+/).filter(s => s.trim());
        const partSize = Math.ceil(scriptParts.length / 10);
        const startIdx = (i - 1) * partSize;
        const endIdx = Math.min(i * partSize, scriptParts.length);
        const segmentText = scriptParts.slice(startIdx, endIdx).join('. ').trim() + '.';

        segments.push({
          index: i,
          audioUrl: data.signedUrl,
          text: segmentText || `Segment ${i}`,
          duration: 0, // Unknown without fetching audio
          size: 0,
        });
      }
    }

    return segments;
  };

  const handleOpenProject = async (project: Project) => {
    // Disable fullAutomation when manually opening a project
    // User wants to review/edit, not auto-skip steps
    setSettings(prev => ({ ...prev, fullAutomation: false }));

    // CRITICAL: Reset ALL state first before loading new project
    // Without this, old project data persists when new project lacks certain fields
    setPendingScript("");
    setConfirmedScript("");
    setPendingAudioUrl("");
    setAudioUrl("");
    setPendingAudioDuration(0);
    setPendingAudioSegments([]);
    setPendingSrtContent("");
    setSrtContent("");
    setPendingSrtUrl("");
    setPendingImages([]);
    setImagePrompts([]);
    setVideoUrl(undefined);
    setVideoUrlCaptioned(undefined);
    setEmbersVideoUrl(undefined);
    setSmokeEmbersVideoUrl(undefined);
    setGeneratedThumbnails([]);
    setSelectedThumbnailIndex(undefined);
    setApprovedSteps({});
    setYoutubeTitle("");
    setYoutubeDescription("");
    setYoutubeTags("");
    setYoutubeCategoryId("27");
    setYoutubePlaylistId(null);
    setGeneratedAssets([]);

    // Set project state
    setProjectId(project.id);
    setVideoTitle(project.videoTitle);
    setSourceUrl(project.sourceUrl || "");

    // Set asset state for ALL views (so back navigation works)
    if (project.script) {
      setPendingScript(project.script);
      setConfirmedScript(project.script);
    }
    if (project.audioUrl) {
      setPendingAudioUrl(project.audioUrl);
      setAudioUrl(project.audioUrl);
    }
    if (project.audioDuration) setPendingAudioDuration(project.audioDuration);

    // Load audio segments - reconstruct from storage if missing
    if (project.audioSegments && project.audioSegments.length > 0) {
      setPendingAudioSegments(project.audioSegments);
    } else if (project.audioUrl && project.script) {
      // Old project without segments - try to reconstruct from storage
      const reconstructed = await reconstructAudioSegments(project.id, project.script);
      if (reconstructed.length > 0) {
        setPendingAudioSegments(reconstructed);
        // Save reconstructed segments to project for future
        upsertProject({
          id: project.id,
          audioSegments: reconstructed,
        }).catch(err => console.error('[handleOpenProject] Failed to save reconstructed segments:', err));
      }
    }

    if (project.srtContent) {
      setPendingSrtContent(project.srtContent);
      setSrtContent(project.srtContent);
    }
    if (project.srtUrl) setPendingSrtUrl(project.srtUrl);
    if (project.imageUrls) {
      setPendingImages(project.imageUrls);
    }
    // Use stored image prompts if available, otherwise create basic ones
    if (project.imagePrompts && project.imagePrompts.length > 0) {
      setImagePrompts(project.imagePrompts);
    } else if (project.imageUrls) {
      const basicPrompts: ImagePromptWithTiming[] = project.imageUrls.map((url, index) => ({
        index: index + 1,
        startTime: "",
        endTime: "",
        startSeconds: 0,
        endSeconds: 0,
        prompt: "",
        sceneDescription: `Image ${index + 1}`,
      }));
      setImagePrompts(basicPrompts);
    }
    // Load video URLs if available
    if (project.videoUrl) {
      setVideoUrl(project.videoUrl);
    }
    if (project.videoUrlCaptioned) {
      setVideoUrlCaptioned(project.videoUrlCaptioned);
    }
    if (project.embersVideoUrl) {
      setEmbersVideoUrl(project.embersVideoUrl);
    }
    if (project.smokeEmbersVideoUrl) {
      setSmokeEmbersVideoUrl(project.smokeEmbersVideoUrl);
    }
    if (project.thumbnails) {
      setGeneratedThumbnails(project.thumbnails);
    }
    if (project.selectedThumbnailIndex !== undefined) {
      setSelectedThumbnailIndex(project.selectedThumbnailIndex);
    }
    if (project.approvedSteps) {
      setApprovedSteps(project.approvedSteps);
    }
    // Restore YouTube metadata
    if (project.youtubeTitle) setYoutubeTitle(project.youtubeTitle);
    if (project.youtubeDescription) setYoutubeDescription(project.youtubeDescription);
    if (project.youtubeTags) setYoutubeTags(project.youtubeTags);
    if (project.youtubeCategoryId) setYoutubeCategoryId(project.youtubeCategoryId);
    if (project.youtubePlaylistId !== undefined) setYoutubePlaylistId(project.youtubePlaylistId);

    // Restore project tags
    if (project.tags) setProjectTags(project.tags);

    // Build generated assets for results view
    const assets: GeneratedAsset[] = [];
    if (project.script) {
      assets.push({
        id: "script",
        name: "Rewritten Script",
        type: "Markdown",
        size: `${Math.round(project.script.length / 1024)} KB`,
        icon: <FileText className="w-5 h-5 text-muted-foreground" />,
        content: project.script,
      });
    }
    if (project.audioUrl) {
      assets.push({
        id: "audio",
        name: "Voiceover Audio",
        type: "MP3",
        size: project.audioDuration ? `${Math.round(project.audioDuration / 60)} min` : "Unknown",
        icon: <Mic className="w-5 h-5 text-muted-foreground" />,
        url: project.audioUrl,
      });
    }
    if (project.srtContent) {
      assets.push({
        id: "captions",
        name: "Captions",
        type: "SRT",
        size: `${Math.round(project.srtContent.length / 1024)} KB`,
        icon: <FileText className="w-5 h-5 text-muted-foreground" />,
        url: project.srtUrl,
        content: project.srtContent,
      });
    }
    if (project.imageUrls) {
      project.imageUrls.forEach((imageUrl, index) => {
        assets.push({
          id: `image-${index + 1}`,
          name: `Image ${index + 1}`,
          type: "PNG",
          size: "~1 MB",
          icon: <Image className="w-5 h-5 text-muted-foreground" />,
          url: imageUrl,
        });
      });
    }
    setGeneratedAssets(assets);

    // Go to results page (last step with all downloads)
    setViewState("results");

    toast({
      title: "Project Opened",
      description: `Loaded "${project.videoTitle}"`,
    });
  };

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <header className="border-b border-border bg-card">
        <div className="container mx-auto px-6 h-16 flex items-center justify-between">
          <button
            onClick={() => setViewState("create")}
            className="flex items-center gap-3 hover:opacity-80 transition-opacity"
          >
            <div className="w-9 h-9 bg-primary rounded-lg flex items-center justify-center">
              <Scroll className="w-5 h-5 text-primary-foreground" />
            </div>
            <span className="text-lg font-semibold text-foreground">
              HistoryVidGen
            </span>
          </button>
          
          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="sm"
              className={`gap-2 ${viewState === "outlier-finder" ? "text-foreground bg-accent" : "text-muted-foreground hover:text-foreground"}`}
              onClick={() => setViewState("outlier-finder")}
            >
              <TrendingUp className="w-4 h-4" />
              <span className="hidden sm:inline">Outliers</span>
            </Button>
            <ConfigModal
              scriptTemplates={scriptTemplates}
              onSaveScriptTemplates={handleSaveScriptTemplates}
              imageTemplates={imageTemplates}
              onSaveImageTemplates={handleSaveImageTemplates}
              cartesiaVoices={cartesiaVoices}
              onSaveVoices={handleSaveVoices}
              voiceSettings={{
                voiceSampleUrl: settings.voiceSampleUrl,
                ttsEmotionMarker: settings.ttsEmotionMarker,
                ttsTemperature: settings.ttsTemperature,
                ttsTopP: settings.ttsTopP,
                ttsRepetitionPenalty: settings.ttsRepetitionPenalty,
                speed: settings.speed,
              }}
              onVoiceSettingsChange={(voiceSettings) => {
                setSettings(prev => ({ ...prev, ...voiceSettings }));
              }}
            />
            <ProjectsDrawer onOpenProject={handleOpenProject} onViewFavorites={() => setViewState("favorites")} />
          </div>
        </div>
      </header>

      {/* Main Content */}
      {viewState === "outlier-finder" ? (
        <OutlierFinderView
          onBack={() => setViewState("create")}
          onSelectVideo={handleSelectOutlierVideo}
        />
      ) : viewState === "favorites" ? (
        <FavoritesView
          onSelectProject={handleOpenProject}
          onBack={() => setViewState("create")}
        />
      ) : viewState === "results" ? (
        <ProjectResults
          sourceUrl={sourceUrl}
          onNewProject={handleNewProject}
          onBack={handleBackToThumbnails}
          assets={generatedAssets}
          srtContent={srtContent}
          imagePrompts={imagePrompts}
          audioUrl={audioUrl}
          audioDuration={pendingAudioDuration}
          projectTitle={videoTitle}
          projectId={projectId}
          videoUrl={videoUrl}
          videoUrlCaptioned={videoUrlCaptioned}
          embersVideoUrl={embersVideoUrl}
          smokeEmbersVideoUrl={smokeEmbersVideoUrl}
          onVideoRendered={(url) => {
            setVideoUrl(url);
            // Save to current project (upsert handles both in_progress and completed)
            autoSave("complete", { videoUrl: url });
          }}
          onCaptionedVideoRendered={(url) => {
            setVideoUrlCaptioned(url);
            autoSave("complete", { videoUrlCaptioned: url });
          }}
          onEmbersVideoRendered={(url) => {
            setEmbersVideoUrl(url);
            autoSave("complete", { embersVideoUrl: url });
          }}
          onSmokeEmbersVideoRendered={(url) => {
            setSmokeEmbersVideoUrl(url);
            autoSave("complete", { smokeEmbersVideoUrl: url });
          }}
          thumbnails={generatedThumbnails}
          selectedThumbnailIndex={selectedThumbnailIndex}
          script={confirmedScript}
          onGoToScript={handleBackToScript}
          onGoToAudio={handleBackToAudio}
          onGoToCaptions={handleBackToCaptions}
          onGoToPrompts={handleBackToPrompts}
          onGoToImages={handleBackToImages}
          onGoToThumbnails={handleBackToThumbnails}
          onGoToRender={handleBackToRender}
          onImagePromptsHealed={(healedPrompts) => {
            console.log(`[Index] Healed image prompts: ${healedPrompts.length}`);
            setImagePrompts(healedPrompts);
            // Save healed prompts to project
            autoSave("images", { imagePrompts: healedPrompts });
          }}
          approvedSteps={approvedSteps}
          onApproveStep={handleApproveStep}
          youtubeTitle={youtubeTitle}
          youtubeDescription={youtubeDescription}
          youtubeTags={youtubeTags}
          youtubeCategoryId={youtubeCategoryId}
          youtubePlaylistId={youtubePlaylistId}
          onYouTubeMetadataChange={(title, description, tags, categoryId, playlistId) => {
            setYoutubeTitle(title);
            setYoutubeDescription(description);
            setYoutubeTags(tags);
            setYoutubeCategoryId(categoryId);
            setYoutubePlaylistId(playlistId);
            // Save YouTube metadata to project
            autoSave("complete", {
              youtubeTitle: title,
              youtubeDescription: description,
              youtubeTags: tags,
              youtubeCategoryId: categoryId,
              youtubePlaylistId: playlistId,
            });
          }}
          onSaveVersion={handleSaveVersion}
          onDuplicate={handleDuplicate}
          onTitleChange={(newTitle) => {
            setVideoTitle(newTitle);
            // Save title change to project
            autoSave("complete", { videoTitle: newTitle });
          }}
          onThumbnailUpload={(thumbnailUrl) => {
            // Add uploaded thumbnail to the list
            const updatedThumbnails = [...generatedThumbnails, thumbnailUrl];
            setGeneratedThumbnails(updatedThumbnails);
            // Auto-select the newly uploaded thumbnail
            setSelectedThumbnailIndex(updatedThumbnails.length - 1);
            // Save to project
            autoSave("complete", {
              thumbnails: updatedThumbnails,
              selectedThumbnailIndex: updatedThumbnails.length - 1
            });
          }}
          tags={projectTags}
          onTagsChange={(newTags) => {
            setProjectTags(newTags);
            // Save tags to project
            autoSave("complete", { tags: newTags });
          }}
        />
      ) : (
        <main className="flex flex-col items-center justify-center px-4 py-32">
          {/* Resume saved project banner */}
          {savedProject && viewState === "create" && (
            <div className="w-full max-w-3xl mx-auto mb-8">
              <div className="bg-primary/10 border border-primary/20 rounded-xl p-4 flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <RotateCcw className="w-5 h-5 text-primary" />
                  <div className="text-left">
                    <p className="text-sm font-medium text-foreground">
                      Resume previous project?
                    </p>
                    <p className="text-xs text-muted-foreground">
                      {savedProject.videoTitle} - {getStepLabel(savedProject.currentStep)}
                    </p>
                  </div>
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={handleDismissSavedProject}
                  >
                    Dismiss
                  </Button>
                  <Button
                    size="sm"
                    onClick={handleResumeProject}
                  >
                    Resume
                  </Button>
                </div>
              </div>
            </div>
          )}

          <div className="w-full max-w-3xl mx-auto text-center space-y-8">
            <div className="space-y-3">
              <h1 className="text-4xl md:text-5xl font-bold text-foreground tracking-tight">
                Create Your History AI Video
              </h1>
              <p className="text-lg text-muted-foreground">
                {settings.customScript && settings.customScript.trim().length > 0
                  ? "Using custom script - click Generate to start audio production"
                  : "From YouTube URL to full production ready assets in minutes"}
              </p>
            </div>

            {/* Inline settings on main page */}
            <div className="w-full max-w-2xl mx-auto bg-card rounded-xl border border-border p-4 space-y-4">
              {/* Project Title */}
              <div className="flex items-center gap-3">
                <label className="text-sm font-medium text-muted-foreground w-28 text-left shrink-0">Project Title</label>
                <Input
                  value={settings.projectTitle}
                  onChange={(e) => setSettings(prev => ({ ...prev, projectTitle: e.target.value }))}
                  placeholder="Enter project title..."
                  className="flex-1"
                />
              </div>

              {/* Word Count */}
              <div className="flex items-center gap-3">
                <label className="text-sm font-medium text-muted-foreground w-28 text-left shrink-0">Word Count</label>
                <div className="flex items-center gap-3 flex-1">
                  <Slider
                    value={[settings.wordCount]}
                    min={500}
                    max={30000}
                    step={100}
                    onValueChange={([value]) => setSettings(prev => ({ ...prev, wordCount: value }))}
                    className="flex-1"
                  />
                  <span className="text-sm text-muted-foreground w-16 text-right">{settings.wordCount.toLocaleString()}</span>
                </div>
              </div>

              {/* Step-by-Step vs Full Auto toggle */}
              <div className="flex items-center gap-3">
                <label className="text-sm font-medium text-muted-foreground w-28 text-left shrink-0">Mode</label>
                <div className="flex bg-muted rounded-lg p-1 flex-1">
                  <button
                    onClick={() => setSettings(prev => ({ ...prev, fullAutomation: false }))}
                    className={`flex-1 py-2 px-3 rounded-md text-sm font-medium transition-colors ${
                      !settings.fullAutomation
                        ? "bg-background text-foreground shadow-sm"
                        : "text-muted-foreground hover:text-foreground"
                    }`}
                  >
                    Step-by-Step
                  </button>
                  <button
                    onClick={() => setSettings(prev => ({ ...prev, fullAutomation: true }))}
                    className={`flex-1 py-2 px-3 rounded-md text-sm font-medium transition-colors ${
                      settings.fullAutomation
                        ? "bg-background text-foreground shadow-sm"
                        : "text-muted-foreground hover:text-foreground"
                    }`}
                  >
                    Full Auto
                  </button>
                </div>
              </div>

              {/* Full Auto Settings - only visible when Full Auto mode is selected */}
              {settings.fullAutomation && (
                <>
                  {/* Image Style */}
                  <div className="flex items-center gap-3">
                    <label className="text-sm font-medium text-muted-foreground w-28 text-left shrink-0">Image Style</label>
                    <Select
                      value={settings.imageTemplate}
                      onValueChange={(value) => setSettings(prev => ({ ...prev, imageTemplate: value }))}
                    >
                      <SelectTrigger className="flex-1">
                        <SelectValue placeholder="Select image style" />
                      </SelectTrigger>
                      <SelectContent>
                        {imageTemplates.map((template) => (
                          <SelectItem key={template.id} value={template.id}>
                            {template.name || template.id}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Image Count */}
                  <div className="flex items-center gap-3">
                    <label className="text-sm font-medium text-muted-foreground w-28 text-left shrink-0">Image Count</label>
                    <div className="flex items-center gap-3 flex-1">
                      <Slider
                        value={[settings.imageCount]}
                        min={1}
                        max={500}
                        step={1}
                        onValueChange={([value]) => setSettings(prev => ({ ...prev, imageCount: value }))}
                        className="flex-1"
                      />
                      <span className="text-sm text-muted-foreground w-16 text-right">{settings.imageCount}</span>
                    </div>
                  </div>
                </>
              )}
            </div>

            {/* Two input modes: YouTube URL or Custom Script */}
            <div className="w-full max-w-2xl mx-auto space-y-4">
              {/* Mode toggle tabs */}
              <div className="flex bg-muted rounded-lg p-1">
                <button
                  onClick={() => {
                    setInputMode("url");
                    setSettings(prev => ({ ...prev, customScript: "" }));
                  }}
                  className={`flex-1 flex items-center justify-center gap-2 py-2 px-4 rounded-md text-sm font-medium transition-colors ${
                    inputMode === "url" && !settings.customScript?.trim()
                      ? "bg-background text-foreground shadow-sm"
                      : "text-muted-foreground hover:text-foreground"
                  }`}
                >
                  <Youtube className="w-4 h-4" />
                  YouTube URL
                </button>
                <button
                  onClick={() => setInputMode("title")}
                  className={`flex-1 flex items-center justify-center gap-2 py-2 px-4 rounded-md text-sm font-medium transition-colors ${
                    inputMode === "title" || settings.customScript?.trim()
                      ? "bg-background text-foreground shadow-sm"
                      : "text-muted-foreground hover:text-foreground"
                  }`}
                >
                  <FileText className="w-4 h-4" />
                  Paste Script
                </button>
              </div>

              {/* YouTube URL mode */}
              {inputMode === "url" && !settings.customScript?.trim() && (
                <div className="bg-card rounded-2xl shadow-sm border border-border p-4 space-y-4">
                  <div className="flex items-center gap-2">
                    <Youtube className="w-5 h-5 text-red-500 shrink-0" />
                    <Input
                      type="url"
                      value={inputValue}
                      onChange={(e) => setInputValue(e.target.value)}
                      placeholder="Paste YouTube URL..."
                      className="flex-1 border-0 bg-transparent focus-visible:ring-0 focus-visible:ring-offset-0 text-base"
                    />
                  </div>
                  <div className="flex items-center gap-2">
                    <Scroll className="w-4 h-4 text-muted-foreground shrink-0" />
                    <Select
                      value={settings.scriptTemplate}
                      onValueChange={(value) => setSettings(prev => ({ ...prev, scriptTemplate: value }))}
                    >
                      <SelectTrigger className="flex-1 border-0 bg-muted/50 focus:ring-0 focus:ring-offset-0">
                        <SelectValue placeholder="Select script template..." />
                      </SelectTrigger>
                      <SelectContent>
                        {scriptTemplates.map((template) => (
                          <SelectItem key={template.id} value={template.id}>
                            {template.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <Button
                    onClick={() => {
                      if (settings.fullAutomation) {
                        toast({
                          title: "Full Auto Mode Active",
                          description: "You're in Full Auto mode. Use 'Full Auto Generate' below, or switch to Step-by-Step mode.",
                          variant: "destructive",
                        });
                        return;
                      }
                      handleGenerate();
                    }}
                    disabled={viewState !== "create" || !inputValue.trim() || settings.fullAutomation}
                    className={`w-full bg-primary hover:bg-primary/90 text-primary-foreground rounded-xl py-6 text-base ${settings.fullAutomation ? 'opacity-50 cursor-not-allowed' : ''}`}
                  >
                    <Sparkles className="w-5 h-5 mr-2" />
                    Generate Script
                  </Button>
                  <Button
                    onClick={() => {
                      setSettings(prev => ({ ...prev, fullAutomation: true }));
                      handleGenerate();
                    }}
                    disabled={viewState !== "create" || !inputValue.trim()}
                    variant="outline"
                    className="w-full rounded-xl py-6 text-base border-primary/30 hover:bg-primary/10"
                  >
                    <Zap className="w-5 h-5 mr-2" />
                    Full Auto Generate
                  </Button>
                </div>
              )}

              {/* Custom Script mode */}
              {(inputMode === "title" || settings.customScript?.trim()) && (
                <div className="bg-card rounded-2xl shadow-sm border border-border p-4 space-y-4">
                  <textarea
                    value={settings.customScript || ""}
                    onChange={(e) => setSettings(prev => ({ ...prev, customScript: e.target.value }))}
                    placeholder="Paste your script here..."
                    className="w-full h-40 p-3 text-sm border rounded-lg resize-none bg-background focus:outline-none focus:ring-2 focus:ring-primary/20"
                  />
                  {settings.customScript?.trim() && (
                    <p className="text-xs text-muted-foreground text-center">
                      {settings.customScript.trim().split(/\s+/).length} words
                    </p>
                  )}
                  <Button
                    onClick={() => {
                      if (settings.fullAutomation) {
                        toast({
                          title: "Full Auto Mode Active",
                          description: "You're in Full Auto mode. Switch to Step-by-Step mode to use Generate Audio.",
                          variant: "destructive",
                        });
                        return;
                      }
                      handleGenerate();
                    }}
                    disabled={viewState !== "create" || !settings.customScript?.trim() || settings.fullAutomation}
                    className={`w-full bg-primary hover:bg-primary/90 text-primary-foreground rounded-xl py-6 text-base ${settings.fullAutomation ? 'opacity-50 cursor-not-allowed' : ''}`}
                  >
                    <Mic className="w-5 h-5 mr-2" />
                    Generate Audio
                  </Button>
                </div>
              )}
            </div>

            {entryMode === "images" && (
              <div className="bg-card rounded-2xl shadow-sm border border-border p-6 space-y-4">
                <p className="text-muted-foreground text-sm">
                  Upload or paste your script and captions (SRT) to generate image prompts.
                </p>

                {/* Project Title input */}
                <div className="space-y-2">
                  <label className="text-sm font-medium text-left block">Project Title</label>
                  <Input
                    value={imagesProjectTitle}
                    onChange={(e) => setImagesProjectTitle(e.target.value)}
                    placeholder="Enter project title..."
                    className="w-full"
                  />
                </div>

                {/* Script input */}
                <div className="space-y-2">
                  <label className="text-sm font-medium text-left block">Script</label>
                  <input
                    ref={scriptFileInputRef}
                    type="file"
                    accept=".txt,.md"
                    onChange={handleScriptFileChange}
                    className="hidden"
                  />
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => scriptFileInputRef.current?.click()}
                    >
                      Upload .txt
                    </Button>
                    <span className="text-xs text-muted-foreground self-center">or paste below</span>
                  </div>
                  <textarea
                    value={uploadedScript}
                    onChange={(e) => setUploadedScript(e.target.value)}
                    placeholder="Paste your script here..."
                    className="w-full h-32 p-3 text-sm border rounded-lg resize-none bg-background"
                  />
                </div>

                {/* Captions input */}
                <div className="space-y-2">
                  <label className="text-sm font-medium text-left block">Captions (SRT)</label>
                  <input
                    ref={captionsFileInputRef}
                    type="file"
                    accept=".srt,.txt"
                    onChange={handleCaptionsFileChange}
                    className="hidden"
                  />
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => captionsFileInputRef.current?.click()}
                    >
                      Upload .srt
                    </Button>
                    <span className="text-xs text-muted-foreground self-center">or paste below</span>
                  </div>
                  <textarea
                    value={uploadedCaptions}
                    onChange={(e) => setUploadedCaptions(e.target.value)}
                    placeholder="Paste your SRT captions here..."
                    className="w-full h-32 p-3 text-sm border rounded-lg resize-none bg-background font-mono"
                  />
                </div>

                {/* Audio file input (optional) */}
                <div className="space-y-2">
                  <label className="text-sm font-medium text-left block">
                    Audio File <span className="text-muted-foreground font-normal">(optional - for accurate timing)</span>
                  </label>
                  <input
                    ref={audioFileInputImagesRef}
                    type="file"
                    accept="audio/*"
                    onChange={handleAudioFileChangeForImages}
                    className="hidden"
                  />
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => audioFileInputImagesRef.current?.click()}
                    className="w-full justify-start"
                  >
                    <Mic className="w-4 h-4 mr-2" />
                    {uploadedAudioFileForImages ? uploadedAudioFileForImages.name : "Choose Audio File"}
                  </Button>
                </div>

                <Button
                  onClick={handleGenerateImagePrompts}
                  disabled={!uploadedScript.trim() || !uploadedCaptions.trim() || viewState !== "create"}
                  className="w-full"
                >
                  <Sparkles className="w-4 h-4 mr-2" />
                  Generate Image Prompts
                </Button>
              </div>
            )}

          </div>
        </main>
      )}

      {/* Processing Modal */}
      <ProcessingModal
        isOpen={viewState === "processing"}
        onClose={handleCancelRequest}
        steps={processingSteps}
      />

      {/* Script Review Modal */}
      <ScriptReviewModal
        isOpen={viewState === "review-script"}
        script={pendingScript}
        title={videoTitle}
        template={scriptTemplates.find(t => t.id === settings.scriptTemplate)?.template}
        onConfirm={handleScriptConfirm}
        onCancel={handleCancelRequest}
        onBack={handleBackToCreate}
        onForward={canGoForwardFromScript() ? handleForwardToAudio : undefined}
        onRegenerate={handleScriptRegenerate}
      />

      {/* Audio Preview Modal - Show segments modal if we have segments, otherwise legacy single audio */}
      {pendingAudioSegments.length > 0 ? (
        <AudioSegmentsPreviewModal
          isOpen={viewState === "review-audio"}
          segments={pendingAudioSegments}
          combinedAudioUrl={pendingAudioUrl}
          totalDuration={pendingAudioDuration}
          onConfirmAll={handleAudioConfirm}
          onRegenerate={handleSegmentRegenerate}
          onCancel={handleCancelRequest}
          onBack={handleBackToScript}
          onForward={canGoForwardFromAudio() ? handleForwardToCaptions : undefined}
          regeneratingIndex={regeneratingSegmentIndex}
        />
      ) : (
        <AudioPreviewModal
          isOpen={viewState === "review-audio"}
          audioUrl={pendingAudioUrl}
          duration={pendingAudioDuration}
          onConfirm={handleAudioConfirm}
          onRegenerate={handleAudioRegenerate}
          onCancel={handleCancelRequest}
          onBack={handleBackToScript}
        />
      )}

      {/* Captions Preview Modal - Review captions and set image count */}
      <CaptionsPreviewModal
        isOpen={viewState === "review-captions"}
        srtContent={pendingSrtContent || ""}
        onConfirm={(srt) => handleCaptionsConfirm(srt)}
        onCancel={handleCancelRequest}
        onBack={handleBackToAudio}
        onForward={canGoForwardFromCaptions() ? handleForwardToPrompts : undefined}
        imageCount={settings.imageCount}
        onImageCountChange={(count) => setSettings(prev => ({ ...prev, imageCount: count }))}
      />

      {/* Image Prompts Preview Modal */}
      <ImagePromptsPreviewModal
        isOpen={viewState === "review-prompts"}
        prompts={imagePrompts}
        stylePrompt={customStylePrompt.trim() || getSelectedImageStyle()}
        onConfirm={handlePromptsConfirm}
        onCancel={handleCancelRequest}
        onBack={handleBackToCaptions}
        onForward={canGoForwardFromPrompts() ? handleForwardToImages : undefined}
      />

      {/* Images Preview Modal */}
      <ImagesPreviewModal
        isOpen={viewState === "review-images"}
        images={pendingImages}
        prompts={imagePrompts}
        srtContent={pendingSrtContent || srtContent}
        onConfirm={handleImagesConfirm}
        onCancel={handleCancelRequest}
        onBack={handleBackToPrompts}
        onForward={() => disableAutoAndGoTo("review-render")}
        onRegenerate={handleRegenerateImage}
        onRegenerateMultiple={handleRegenerateMultipleImages}
        regeneratingIndex={regeneratingImageIndex}
        regeneratingIndices={regeneratingImageIndices}
      />

      {/* Video Render Modal (basic video, no effects) */}
      <VideoRenderModal
        isOpen={viewState === "review-render"}
        projectId={projectId}
        projectTitle={videoTitle}
        audioUrl={pendingAudioUrl}
        imageUrls={pendingImages}
        imageTimings={imagePrompts.map(p => ({ startSeconds: p.startSeconds, endSeconds: p.endSeconds }))}
        srtContent={pendingSrtContent}
        existingVideoUrl={videoUrl}
        autoRender={settings.fullAutomation}
        onConfirm={handleRenderConfirm}
        onCancel={handleCancelRequest}
        onBack={handleBackToImages}
        onSkip={handleRenderSkip}
        onForward={() => disableAutoAndGoTo("review-effects")}
      />

      {/* Visual Effects Modal (smoke + embers, auto-renders) */}
      <VisualEffectsModal
        isOpen={viewState === "review-effects"}
        projectId={projectId}
        projectTitle={videoTitle}
        audioUrl={pendingAudioUrl}
        imageUrls={pendingImages}
        imageTimings={imagePrompts.map(p => ({ startSeconds: p.startSeconds, endSeconds: p.endSeconds }))}
        srtContent={pendingSrtContent}
        existingVideoUrl={smokeEmbersVideoUrl}
        onConfirm={handleEffectsConfirm}
        onCancel={handleCancelRequest}
        onBack={handleBackToRender}
        onSkip={handleEffectsSkip}
        onForward={() => disableAutoAndGoTo("review-thumbnails")}
      />

      {/* Thumbnail Generator Modal */}
      <ThumbnailGeneratorModal
        isOpen={viewState === "review-thumbnails"}
        projectId={projectId}
        projectTitle={videoTitle}
        script={confirmedScript}
        initialThumbnails={generatedThumbnails}
        initialSelectedIndex={selectedThumbnailIndex}
        favoriteThumbnails={favoriteThumbnails}
        onFavoriteToggle={handleFavoriteThumbnailToggle}
        onConfirm={handleThumbnailsConfirm}
        onCancel={handleCancelRequest}
        onBack={handleBackToEffects}
        onSkip={handleThumbnailsSkip}
        onForward={() => disableAutoAndGoTo("review-youtube")}
      />

      {/* YouTube Upload Modal */}
      <YouTubeUploadModal
        isOpen={viewState === "review-youtube"}
        videoUrl={renderedVideoUrl || ""}
        projectTitle={videoTitle}
        script={confirmedScript}
        thumbnails={generatedThumbnails}
        selectedThumbnailIndex={selectedThumbnailIndex}
        onClose={handleYouTubeComplete}
        onSuccess={handleYouTubeComplete}
        onBack={handleBackToThumbnails}
        onSkip={handleYouTubeSkip}
      />
    </div>
  );
};

export default Index;
